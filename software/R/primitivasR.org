#+TITLE: Primitivas en GNU R
#+LANGUAGE: es
#+AUTHOR: David Arroyo Menéndez

* Instalación
** Debian/Ubuntu
En Debian/Ubuntu encontraremos paquetes R empaquetados con el sufijo
r-base o r-cran, buscando con apt-cache search. Es posible usar
metapaquetes dependiendo de la versión como r-recommended

** R Commander
Para las personas que vienen adictas a SPSS y similares, puede ser
necesario instalarse R para empezar a cuestionar utilizarlo. Por
favor, no olviden que la estadística es programación no manejo de un
interfaz. Para instalarlo también es posible usar paquetería Debian como

#+BEGIN_SRC
$ sudo apt-get install r-cran-rcmdr
#+END_SRC

Y después ejecutar:

#+BEGIN_SRC
$ R
> library("Rcmdr")
#+END_SRC

** Paquetería R

La ventaja de R frente a otras opciones para hacer estadística es el
enorme número de paquetes. R tiene facilidades propias si su sistema
operativo no tiene soporte, o no le apetece utilizarlo.

#+BEGIN_SRC
> install.packages("snow")
#+END_SRC

* Básicas
** Configuración del Entorno

#+BEGIN_SRC R
$ R                           # Para entrar en el entorno R una vez instalado
                              # es necesario ejecutar la R desde la consola
getwd() 				      # Devuelve el
                                              # directorio de trabajo
setwd("/home/davidam/public_html/software/R") # Cambia el directorio
                                              # de trabajo (debe
                                              # existir previamente)
list.files()				      # Lista el contenido
                                              # del directorio
                                              # de trabajo. Tambien ls()

source("/home/davidam/public_html/software/R/ejercicios-descriptivos.R")

q()                                           # Salir del entorno
#+END_SRC

** Ayuda on-line en R

#+BEGIN_SRC R
   help (aov)
   ?mean
   help.search('mean')
   ??'standard deviation'
   help.start() 			# abre una ventana del navegador
   example (mean)			# ejemplos del uso de mean
#+END_SRC

** Operaciones Aritméticas

#+BEGIN_SRC R
   5+7		# se evalua y el resultado se imprime
                # por pantalla pero no se guarda
   5**7
   5-7
   5/7
   5^7          # elevado a
   51 %% 7	# modulo (resto de una division entera)
   51 %/% 7	# division entera
#+END_SRC

** Asignacion de valores a variables

#+BEGIN_SRC R
   x <- 1	# asigna el valor 1 a la variable x
   x 		# lo escribe por pantalla
   y <- x^2
   x = 1	# una alternativa
   1 -> x 	# otra alternativa
#+END_SRC

** Funciones

#+BEGIN_SRC R
   q	# Muestra informacion de la funcion
   ?q
   # Algunas funciones elementales: log(), log10(),
   # exp(), sqrt(), sin(), cos(), tan()
   # Mas funciones basicas: c(), max(), min(),
   # pmax(), pmin(), range(), length(), sort()
   # sum(), rowSums(), prod(), mean(), colMeans(),
   # var(), cumsum(), etc.
   c(2,69,5,47,3647)
   sum(1,3,5,7)
   raiz64 <- sqrt(64)	# el resultado de una funcion
                        # puede guardarse en una variable
   print(x)
   print(pi,digits=16); print(pi,digits=5)
#+END_SRC

** Listar y Eliminar Objetos del Espacio de Trabajo

#+BEGIN_SRC R
   ls()
   rm(x,raiz64)
   ls()
   rm(list=ls())
   ls()
#+END_SRC
* Tipos de Datos
** Booleanos
#+BEGIN_SRC R
verdad <- T
mentira <- F
edad <- c(27,30,29);
is.numeric(edad)
is.integer(edad)
is.double(edad)	# tambien existen is.complex(),
                # is.logical(), is.character()...
typeof(edad)	# devuelve el tipo del objeto
                # introducido como argumento
#+END_SRC
** Arrays
#+BEGIN_SRC R
calle <- c("c/ rue del percebe","28013");
#+END_SRC
** Conversiones de Tipo
#+BEGIN_SRC R
as.character(verdad)
as.numeric(verdad)		# doble precision por defecto
y <- c(0,1,27,14.9,NA,-3.2);y	# ojo, trunca en vez de redondear
as.logical(y)
as.character(y)
as.integer(y)
y<-c("hola", "adios","true","TRUE", "T", "F","129",NA ,"6");y
as.logical(y)
as.numeric(y)
#+END_SRC

* Vectores
** Básico
#+BEGIN_SRC R
x <- c(1,4,6,3,7); x
x[3]			# devuelve el valor guardado en 3a posicion
x[-4]			# devuelve todo excepto el valor
                        # guardado en 4a posicion
x[1] <- 35		# guarda el valor 35 en la primer posicion
length(x)		# devuelve la longitud de x
x[11] <- 99; x
#+END_SRC
** Calculo vectorizado. Equivale a un bucle implicito
#+BEGIN_SRC R
x <- c(1,2,3,4,5)
y <- c(5,4,3,2,1)
x+y
y <- c(1,2,3);y
suma <- x+y; suma		# recicla el vector mas corto
suma2 <- x-1			# con escalares parece mas natural
x <- c(0.0001, 0.001, 0.01, 0.1, 1)
log10(x)			# muchas funciones tambien se
                                # aplican vectorizadamente
#+END_SRC
** Generacion de secuencias regulares
#+BEGIN_SRC R
1:10
1:10-1				# el operador ':' tiene maxima prioridad
1:{10-1}
#funcion seq(from, to, by, length)
x <- seq (-3,3,0.5);x		# valores desde -3 hasta 3 a intervalos de 0.5
seq (-3,3,length=10)		# 10 valores equiespaciados desde -3 hasta 3
seq (-3, by=0.5,length=10)	# 10 valores a intervalos de 0.5 desde -3
seq(along=x)			# Genera la secuencia 1, 2, 3,..., length(x)
#funcion rep(x, times, each)
x <- 1:4
rep(x,times=3)			# repite el contenido de x tres veces
rep(x,each=3)		        # repite cada elemento de x tres veces
rep(x,times=2,each=3)
rep(c(0,1),times=c(4,3))	# 'times' puede ser un vector. Aqui ya no cabe 'each'
x <- seq(19,6,-3);x
rep(x,1:length(x))		# 'times' puede estar implicito times={1:length(x)}
#+END_SRC
** Ordenacion de vectores
#+BEGIN_SRC R
x <- c(20,80,30,50,0)
order (x, decreasing=F)		# devuelve las posiciones del vector ordenadas segun su contenido
sort (x, decreasing=F)		# devuelve el contenido del vector ordenado
rank(x)				# devuelve el orden de cada posicion segun su contenido
min(x)
which.min(x)			# equivale a which(x == min(x))
x <- c(1,1,3:1,1:4,3); y <- c(0,9:1)
x.ord <- order(x,y)		# ordena los valores de x y, en caso de empate, utiliza los valores de y en las posiciones correspondientes. Ambos, x e y deben tener la misma longitud
x.ord;x;y
#+END_SRC
** Operadores comparativos: <, <=, >, >=, ==, !=
#+BEGIN_SRC R
x <- c(1:10); x
valor.verdad <- x>5; valor.verdad
x <- 1:10
x[x >= 5] <- 20; x	# condicional implicito
x[x == 1] <- 25; x
x <- 1:3; y <- 1:3
x == y			# equivalente a identical(x, y) o all.equal(x, y, tol=0)
y <- y+0.001; y
identical(x, y)
all.equal(x, y, tol=0.001)
#+END_SRC
** Operadores logicos: &,|, !, xor()
#+BEGIN_SRC R
a<-c(TRUE,TRUE,FALSE,FALSE)
b<-c(F, T, F, T)
a&b
a|b
!(a&b)
(!a)|(!b)
#+END_SRC
** Identificacion y sustitucion de valores perdidos. Funciones is.na() y which()
#+BEGIN_SRC R
rm(list=ls())
x <- c(3,6,4,2,8,9)
print (x); length(x)
x[8:10] <- 3;x
is.na(x)
!is.na(x)
which(is.na(x))
x[is.na(x)]<-999;x	# codifica como 999 los valores perdidos
x==NA  			# la expresion logica x == NA sa un resultado muy distinto de
is.na(x)
#+END_SRC

Entonces si tenemos data$q_005 como un frame con algunos datos
perdidos y queremos solo los datos no perdidos podemos hacer

#+BEGIN_SRC
data5 <- data$q_005[!is.na(data$q_005)]
#+END_SRC

** Indeterminaciones e infinito
#+BEGIN_SRC R
x <- c(0,7,8); x/x
1/x
-1/x
is.nan(x)
is.nan(x/x)
is.nan(1/x)
# Hay que tener cuidado con los NaN porque cualquier operacion con un NaN resulta en un NaN
#+END_SRC
** Manipulacion de vectores de caracteres
#+BEGIN_SRC R
# Concatena objetos en un vector de caracteres. Funcion paste(..., sep = " ", collapse = NULL)
juntar <- paste("Una ", "frase ", "cualquiera",  collapse ="");juntar
v1<-c("A","B")
v2<-2:3
codigos <- paste(v1,v2, sep = "");print(codigos)
codigos <- paste(v1,v2, sep = ".");print(codigos)
x <- paste(LETTERS[1:5]);x
x <- paste(LETTERS[1:5], collapse="");x

# Concatena e imprime. Funcion cat(... , file = "", sep = " ", fill = F, labels = NULL, append = F)
verano <- month.abb[7:9]; verano
cat(verano)			# el resultado no puede guardarse en ua variable
cat(verano,"\n")
cat(verano, sep=',')		# concatena separando con comas e imprime
cat(verano, sep=';', fill=3)
cat("Estaciones:","\t","Moncloa","\n", "\t", "\t","Aluche","\n")

#Todo junto: cat() y paste()
x<-2/3; cat(paste("resultado", signif(x,2), sep=" : " ),"\n")
#+END_SRC
** Indexacion de vectores mediante variables de caracteres. Funcion names()
#+BEGIN_SRC R
edad <- c(12,22,15,16,10)
names(edad)						# por defecto no se asignan nombres
names(edad) <- paste("suj#", sep = "",length(edad):1); edad
names(edad)
edad["suj#2"]					# devuelve la edad de Sujeto #2 (almacenado en la penultima posicion)
edad[length(edad)-1]
names(edad) <- NULL; edad	# elimina los nombre asignados
#+END_SRC
* Factores
Son vectores para datos categoricos. Permiten prescindir de la
codificacion numerica y referirse a los niveles mediante nombres
#+BEGIN_SRC R
   estudios <- c(1,3,1,1,3,4,3)
   factor(estudios)
   nivel.estudios <- factor(estudios, levels=1:4,labels=c("primarios", "secundarios", "superiores", "doctorado"), ordered=T)
   nivel.estudios
   factor(c(5,2,2,4,5,4,3,3,1), 2:5, exclude=4)	# los valores 1 y 4 se consideran valores perdidos
   # OJO. Internamente R siempre se asigna 1 al primer nivel del factor, 2 al segundo etc.
   levels(nivel.estudios)			# levels() extrae los posibles niveles de un factor
   as.numeric(nivel.estudios)		# recodifica el factor numericamente
   codigo.postal <- factor(c('28011', '28044', '28011','28013', '28013','28023'))
   equipo.futbol <- factor(c('VAL', 'VAL', 'FCB','VAL', 'FCB','ATM'))
   equipo.futbol						# ordena los factores alfabeticamente
   as.numeric(equipo.futbol)
   as.character(equipo.futbol)	# convierte en cadenas de caracters no en factor de nuevo
#+END_SRC

* Matrices
Suponen la generalizacion de vectores a 2D.
Todos los elementos de una matriz deben ser del mismo tipo.
Una convencion relativamente extendida es cmenzar con mayuscula el nombre de una matriz
** Función matrix()
#+BEGIN_SRC R
   X <- 1:12
   dim(X) <- c(4,3); X # los elementos se organizan por columnas
   matrix(1:12,nrow=3,ncol=4,byrow=T)
   matrix(1:12,nrow=4,byrow=T)
   Mi.matriz <- matrix(1:12,3,4,F); Mi.matriz
   tamano <- dim(Mi.matriz)		# otro uso de dim(); devuelve las dimensiones de la matriz
   rownames(Mi.matriz) <- LETTERS[1:tamano[1]]; Mi.matriz
   colnames(Mi.matriz) <- paste("Var",1:tamano[2], sep=""); Mi.matriz
   dimnames(Mi.matriz)
#+END_SRC
** Concatenación de matrices
#+BEGIN_SRC R
   X1 <- c(3,7,5)
   X2 <- c(8,3,1)
   Xx <- cbind(X1,X2);Xx
   Yy <- rbind(X2,X1);Yy
   Zz <- cbind(X1,Xx);Zz
#+END_SRC
** Indexacion de matrices
#+BEGIN_SRC R
   X <- matrix(c(1,4,12,15),2,2);X
   X[1,2]				# elemento guardado en la 1a fila, 2da columna
   X[1, ]				# todos los elementos de la primera fila
   X[ ,2]				# todos los elementos de la segunda columna
   X[3]   				# para pensar un poco...
   Mi.matriz['B',]	#tambien se pueden usar los nombres (se han asignado)
#+END_SRC
** Operaciones con matrices
#+BEGIN_SRC R
   X <- matrix(c(1,4,12,15),2,2); X
   Y <- matrix(1:4,2,2); Y
   X+Y
   X-Y
   X%*%Y						# producto matricial
   X*Y						# producto elemento por elemento
   t(X)						# traspuesta
   det(X)					# determinante
   X.inv <- solve (X)	# inversa de X (siempre que X sea cuadrada no singular, claro)
   X.inv
   X%*%X.inv				# Comprueba el resultado. Ojo a los errores de redondeo
   # En general, solve(a,b) es una funcion que resuelve a %*% x = b para x, donde b puede ser un vector o una matriz. Si no se explicta se asume que es la matriz identidad y la funcion devuelve la inversa de a
   A <- matrix(c(1,4,12,15),2,2); A
   B <- matrix(c(5,2),2,1);B
   X <- solve(A,B); X
   A%*%X			# comprueba que el resultado es efectivamente B
#+END_SRC
** Algunas funciones que operan sobre filas o columnas completas
#+BEGIN_SRC R
   X <- matrix(c(1,4,12,15),2,2); X
   rowSums(X)
   colSums(X)
   rowMeans(X)
   colMeans(X)
#+END_SRC
** Apply
#+BEGIN_SRC R
   apply(X,1,sum)		# suma por filas; equivale a rowSums(X)
   apply(X,2,mean)	# media por columnas; equivale a colMeans(X)
   apply(X,1,sd)
#+END_SRC
** Matrices multidimensionales (arrays)
#+BEGIN_SRC R
   A <- array(1:24, c(3, 4, 2)); A
   dimnames(A) <- list(c("fila1", "fila2", "fila3"), c("col1", "col2", "col3", "col4"), c("capa 1", "capa 2"));A
#+END_SRC
* Listas
Son una especie de contenedores generales donde pueden mezclarse todo
tipo de componentes (objetos de cualquier tipo y cualquier longitud)

Son unos objetos poco estructurados y, por tanto, muy flexibles.

Muchas funciones nativas de R devuelven el resultado en forma de
lista
#+BEGIN_SRC R
   rm(list=ls())
   mis.num <- seq(1.0, 2.0, 0.1); mis.num2 <- 2:4
   Mi.matriz <- matrix(1:12,3,4); Mi.matriz
   mis.caracteres <- paste(LETTERS[1:5]);mis.caracteres
   mis.logicos <- mis.num > 1.65; mis.logicos
   lista1 <- list(mis.num, mis.num2, Mi.matriz, mis.caracteres,mis.logicos)
   lista1
#+END_SRC
** Indexacion, nombres y atributos
#+BEGIN_SRC R
   length(lista1)		# devuelve el numero de componentes de la lista
   str(lista1) 		# devuelve informacion sobre la estructura de la lista
   a <- lista1[[1]]	# devuelve el 1er objeto de la lista en forma de vector/matriz (y nombre  excluido)
   a; typeof(a)
   b <- lista1[1]		# devuelve una sublista compuesta por los elementos de la 1a entrada de la lista (nombre incluido)
   b; typeof(b)

   nomb <- c("reales","enteros", "matriz", "caracteres", "logicos")
   names(lista1) <- nomb; 	# asigna nombres a los componenes de la lista
   names(lista1)				# devuelve los nombres de los componentes (si los hay)
   lista1[["reales"]]
   lista1$logicos 			# equivalente a lista1[["logicos"]] y a lista[[5]]

   # Otro modo de definir una lista que incluye nombres para los componentes
   lista2 <- list(A=mis.num, B=mis.num2); lista2
   names(lista2)
#+END_SRC

** Attach
Las funciones attach() y detach () "cargan" listas y simplifican las referencias.
#+BEGIN_SRC R
   attach(lista1, warn.conflicts = T)
#+END_SRC

* Hojas de datos (data frames)
Son un tipo especial de lista:
+ con estructura tabular
+ donde las columnas pueden ser de distinto tipo
+ suelen utilizarse como bases de datos donde cada fila representa una unidad de observacion y cada columna una variable

#+BEGIN_SRC R
   var1 <- seq(150,700,50); var2 <- 6:17; var3 <- c(10, 35, 17); var4 <- 2:8
   data.frame(var1, var2)
   data.frame(var1, var3) # recicla var3
   data.frame(var1, var4) # mensaje de error porque la longitud var1 no es multiplo de la de var4
   var5 <- factor(rep(c(2,1,1,1), times=3), levels=1:2, labels=c("UsaTwitter", "NoUsaTwitter"));var5
   mis.datos <- data.frame(var5, var1, var2, var3);mis.datos # por defecto los nombres de las columnas corresponden a los nombres de los objetos
   # para nombrar las filas (no siempre necesario)
   row.names(mis.datos) <- paste("suj",1:max(length(var1),length(var2),length(var3)), sep='');mis.datos	# Equivale a rownames(mis.datos)
#+END_SRC

** Algunos atributos
#+BEGIN_SRC R
   rownames(mis.datos); colnames(mis.datos)
   dim(mis.datos)				# dimensiones
   str(mis.datos)				# estructura
   attributes(mis.datos)	# clase y nombres de fila y columna
#+END_SRC

** Particiones de una hoja de datos segun un factor, funcion split()
Uso: split (x, factor). unsplit(x, factor)
#+BEGIN_SRC R
   trozos <- split (mis.datos, mis.datos$var5); trozos		# devuelve una lista "trozos" con los valores de var1 segregados segun var5
   typeof(trozos)
   junto.otravez <- unsplit(trozos, mis.datos$var5); junto.otravez

   # el 2do argumento funciona como factor, no es necesario que este definido como tal.
   # Ademas se pueden seleccionar solo algunas variables (ej, var2 y var3)
   trozos <- split (c(mis.datos$var1,mis.datos$var2), mis.datos$var3); trozos

   # lo mismo podria conseguirse con una sucesion de instrucciones como esta:
   twitter.si <- mis.datos[mis.datos$var5=="UsaTwitter",];twitter.si
#+END_SRC

** Filtrado segun condiciones logicas. Función subset()
Uso: subset(x, subset, select)
#+BEGIN_SRC R
   subset(mis.datos, var3 >= 15)
   subset(mis.datos, var3 >= 15, select=c(var1,var2))
   subset(mis.datos, var3 >= 15, select=-var3)
#+END_SRC

#+BEGIN_SRC R
   subset(data$q_005, (data$q_005 > 1900) & (data$q_005 < 2013))
#+END_SRC

** Transformaciones de datos, funcion transform()
Uso: transform()
#+BEGIN_SRC R
   mis.datos2 <- transform (mis.datos, log.var1= log(var1)); mis.datos2
#+END_SRC

** Edición manual de bases de datos
R dispone de una utilidad de aspecto sejemante a una hoja de calculo para:
+ introducir datos manualmente
+ modificar unos pocos elementos de bases de datos existentes

#+BEGIN_SRC R
  edit(data.frame())			# abre el editor con una 'hoja de datos' vacia
						# los huecos se rellenaran solos con NA
						# doble click en "var?" para cambiar el nombre de la variable
 						# ¿que ha pasado?, ¿donde estan los datos?
   respuestas <- edit(data.frame())	# Es esencial asignarle un nombre a la hoja de datos
   respuestas
   respuestas2 <- edit(respuestas)	# guarda los cambios en una nueva hoja de datos (y conserva la antigua)
   respuestas;respuestas2
   fix(respuestas)						# sobreescribe los cambios. Es equivalente a respuestas <- edit(respuestas)
#+END_SRC

* Cargar datos nativos de R
La instalacion basica de R incluye el paquete 'datasets'.
#+BEGIN_SRC R
   data()									# lista todas las bases de datos disponibles en datasets'
   help(women)								# informacion sobre ese conjunto de datos concreto
   data(women, package="datasets")	# carga esos datos
   # Si el paquete de procedencia esta cargado basta simplemente:
   women
   data(women)								# Equivalente data('women')
#+END_SRC
Muchos paquetes adicionales tambien vienen con sus datos de ejemplo

* Paquetes R
Cargar un paquete. Requiere instalarlo previamente bien:
+ descargandolo en www.r-project.org y siguiendo las instrucciones
+ utilizando el menu windows de RGui y eligiendo un repositorio
#+BEGIN_SRC R
   library (foreign)			# o mediante el menu windows de RGui
   library(help=foreign) 	# informacion sobre el paquete 'foreign'
#+END_SRC

** Ruta de busqueda (search path).
Puede haber muchos objetos con el mismo nombre en distintos paquetes.
La ruta de busqueda explicita el orden en que se van a recorrer los
paquetes para buscar objetos partes deOrden en el que R
#+BEGIN_SRC R
   search()		# muestra la ruta de busqueda
   # Cuidado con los nombres de las variables del espacio de trabajo: Tienen prioridad
   rm(list=ls())
   women
   attach(women)
   mean(weight)
   weight <- 0; mean(weight)
   mean(women$weight)
#+END_SRC

** ACERCA de attach()
attach() inserta el paquete en la ruta de busqueda de R de modo que todos los objetos del paquete estan accesibles mediante sus nombres
Uso: attach(what, pos = 2, name = deparse(substitute(what)), warn.conflicts = TRUE)
Precauciones:
+ Cuidado con el enmascaramiento (nombres duplicados)
+ attach no proporciona actualizacion dinamica de los objetos

*** Retirar paquetes
#+BEGIN_SRC R
   detach (package:ISwR)
   detach()		# elimina el paquete que haya en 2a posicion
   plot(c(1,2,5,6), c(2,5,6,7)) # representa un diagrama de dispersion (vease la seccion 'Graficos')
   detach()		# elimina el nuevo 2do paquete
   plot(c(1,2,5,6), c(2,5,6,7))
#+END_SRC

* Escritura de datos en un archivo
** Guardar en un archivo de texto plano una hoja de datos. Funcion write.table()
#+BEGIN_SRC R
   rm(list=ls())
   data(women)
   write.table(women, "../datos/mujeres.dat", append=T)	# Si la carpeta datos no existe previamente dara un mensaje de error
   ?write.table
   write.table(women, "../datos/mujeres.dat", append=T, row.names=F, col.names= F, sep='', dec=',')
   write.table(women, "../datos/mujeres.dat", append=F,quote=F)
#+END_SRC

** Guadar en texto plano cualquier objeto. Funcion write(). Es mas general, pero no funciona bien con data frames
#+BEGIN_SRC R
   x<-seq(1,3,0.1)
   write(x,"../datos/numeros.dat", ncolumns=1,append=T)
   write(x,"../datos/numeros.dat", ncolumns=length(x),append=F)
#+END_SRC

* Lectura de datos desde un archivo
** Informacion completa en el manual "R Data Import/Export" accesible desde la ayuda
#+BEGIN_SRC R
   ?read.table
   rm(list=ls())
   mis.datos <- read.table("../datos/mujeres.dat", header=T, check.names=T, sep=" ",na.strings=999, comment.char = "#")
   edit(mis.datos)
   median(mis.datos$weight)
   colMeans(mis.datos)
   attach(mis.datos)
   sum(weight >=125)/length(weight)		# calcula la proporcion de individuos que pesan al menos 125 lb
#+END_SRC

** Existen variantes de read.table() para formatos algunos formatos habituales: read.csv, read.csv2, read.delim ...
Tambien hay multiples paquetes como 'foreign' para leer archivos creados por programas como SPSS, SAS, Minitab, etc.,
aunque resulta mas comodo usar esos programas para guardar los datos en texto plano y usar read.table para importar a R

#+BEGIN_SRC R
   library(foreign)	# En primer lugar hay que cargar el paquete
   mi.encuesta.spss <- read.spss("../datos/SurveyStatisticsI.sav", to.data.frame=T)
   edit(mi.encuesta.spss)
#+END_SRC

Mas informacion sobre el uso de foreign en el pdf descargable junto
con el paquete.

Paquete para importar y exportar datos de excel: ‘xlsReadWrite’ (no
incluido en el sistema base; hay que importarlo)

** Funcion scan().
Mas flexible pero mas complicada de utilizar. Permite especificar el modo de las variables
#+BEGIN_SRC R
   ?scan
   mis.datos <- scan("../datos/mujeres.dat", what = list(character(), numeric(),numeric()), skip=1);mis.datos
   mis.datos2 <- scan("../datos/mujeres.dat", what = list(0,0,0), skip=3)
#+END_SRC

* Gráficos
R tiene un sistema de graficos muy completo que permite producir graficos con calidad de publicacion
Hay múltiples funciones, parametros y paquetes graficos. Se van aprendiendo a medida que se van utilizando
Para una buena introduccion: R for Beginners de E. Paradis (citado en la documentacion)
** Gestion de ventanas graficas
#+BEGIN_SRC R
   x11()									# abre una nueva ventana grafica (Unix y Wndows)
   windows(width=15, height=15, title='Figura 1')	# abre una nueva ventana grafica (Windows)
   quartz()								# abre una nueva ventana grafica (Mac OS)
   pdf("prueba.pdf")					# abre un pdf de nombre "prueba.pdf" y redirige el output gráfico al archivo pdf
   postscript("prueba.eps")		# abre un archivo de postscript encapsulado de nombre "prueba.eps" y redirige el output gráfico

   dev.list()	# lista todos los dispositivos grafico abiertos. Los nums son los identificadores
   dev.cur() 	# devuelve el identificador del dispositivo grafico activo
   dev.set(2)	# establece como dispositivo gráfico activo el dispositivo num 2
   dev.off() 	# cierra el dispositivo grafico activo; dev.off(3) cierra el dispositivo grafico num 3
#+END_SRC

** Funcion plot(). Es la función gráfica basica.
Segun los argumentos puede generar un diagrama de dispersion, de barras, caja y bigotes etc.
#+BEGIN_SRC R
   x <- 1:15; y <- 30:16
   # con datos cuantitativos produce diagramas de dispersion
   plot (x,y, pch=2)
   plot(women)		# puede usarse una hoja de datos o matriz. OJO solo toma las 2 primeras columnas
   plot(y)			# representa los valores de 'y' en funcion de su posicion en el vector

   # plot (factor) produce un diagrama de barras
   f <- factor(rep(c(1,2,2,1,1,3), each=2), levels=1:3, labels=c("No fumador", "Fumador", "NS/NC"))
   plot(f)
   # tambien existe la funcion barplot para crear diagramas de barras

   # plot (var.cuant, factor) produce diagramas de caja organizados según los niveles del factor
   entorno <- factor(rep(c(1,2,2), each=5), levels=1:2, labels=c("Urbano", "Rural"))
   plot(entorno,y)
#+END_SRC
** Plot a Png
Se usa la función png para almacenar la salida en un fichero de imagen.
#+BEGIN_SRC R
   x <- 1:15; y <- 30:16
   # con datos cuantitativos produce diagramas de dispersion
   png(filename="/tmp/figure.png", height=295, width=300, bg="white")
   plot (x,y, pch=2)
   dev.off()
#+END_SRC
** Funcicion coplot(). Matriz de graficos de dispersion separados segun factores
#+BEGIN_SRC R
   datos2 <- data.frame(entorno,women)
   coplot(women$weight ~ women$height | entorno) # representa peso en funcion de altura separando segun entorno
   socioeconomico<- factor(c(3,3,2,2,2,2,1,1,1,1,1,1,1,2,2), levels=1:3, labels=c("bajo","medio","alto"))
   plot(socioeconomico)
   coplot(women$weight ~ women$height | entorno+socioeconomico)
#+END_SRC

** Funcion pairs(). Ejemplo con datos simulados de los "Big Five" de personalidad
#+BEGIN_SRC R
   pers <- matrix(rnorm(1000), ncol = 5)	# genera 1000 datos con distribucion normal. Vease seccion 'Muestreo y probabilidad'
   colnames(pers) <- c("extraversion", "estabilidad", "apertura", "responsabilidad", "amabilidad")
   pairs(pers)
   # Nótese la diferencia con el resultado de plot()
   x11(); plot(pers)			# usa solo las 2 primeras variables
#+END_SRC

** Funcion hist(). Histogramas
#+BEGIN_SRC R
   pers <- as.data.frame(matrix(rnorm(1000), ncol = 5))
   colnames(pers) <- c("extraversion", "estabilidad", "apertura", "responsabilidad", "amabilidad")
   cor(pers, method='pearson')	# matriz de correlaciones. Otros metodos: 'spearman' y 'kendall'
   round(cor(pers),3)	# la misma matriz de antes, pero con solo 3 decmales
   attach(pers)
   hist(extraversion)
   x11(); hist(extraversion, labels=T, col= "gray", xlim=c(-4,4), ylab="Frecuencia absoluta", sub= "Figura 1. Ejemplo de histograma", main= "Extraversión")
   hist(amabilidad, col= "red", border="white", add=T, xlim=c(-4,4), sub= "Figura 2. Otro ejemplo de histograma", main= c("Extraversión  Amabilidad superpuestos"))
   x11(); hist(extraversion,freq=F, labels=T, col= "light blue",xlim=c(-4,4),ylab="Frecuencia relativa", las=1,sub= "Figura 1b. Ejemplo de histograma", main= "Extraversión")
   hist(amabilidad, col= "gray", border="white", xlim=c(-4,4), sub="", main= "Figura 3. Otro ejemplo de histograma cambiando el color")

   pdf("ejemplos_histograma.pdf")
   hist(extraversion, nclas=3, col= "light blue", sub= "Figura 3. Ejemplo de histograma", main= "Extraversión")
   hist(extraversion, breaks=seq(-4,4,0.5),col= "pink",main= "Figura 3. Ejemplo de histograma")
   dev.off()
#+END_SRC

** Funcion boxplot()
#+BEGIN_SRC R
   boxplot(extraversion, main= "Diagrama de caja de extraversión")
   text(locator(5),"más outliers", adj=0)
   boxplot(pers)
#+END_SRC

** Funciones qqnorm() y qline
#+BEGIN_SRC R
   qqnorm(extraversion, col="red")
   qqline(extraversion)
#+END_SRC
Tambien existe qqplot(), que permite utilizar otras distribuiones distintas de la normal

** Catalogo de nombres de color
#+BEGIN_SRC R
   colors()
#+END_SRC

** Parametros gráficos. Funcion par()
Produce cambios permanentes en el dispositivo gráfico activo
Permite contral cada elemento del grafico final
#+BEGIN_SRC R
   ?par
   par.actual <- par()		# guarda los valores actuales (para poder reestablecerlos posteriormente)
   par(font.main=4, las=1, xaxs= "r", col.lab="blue", col="skyblue3",lwd=3)
   hist(extraversion,xlim=c(-4,4))
   plot(extraversion, amabilidad)
#   par(par.actual)			# reestablece los valores guardados
   par(mfrow=c(2,1))		# distribuye el espacio grafico e dos filas
#+END_SRC

** Representacion de funciones
#+BEGIN_SRC R
   curve(x^2)
   curve(x^2, from=-3, to=3) # los cambios introducidos a traves de par no tienen efecto en la nueva ventana
   # tambien podria haberse hecho con plot
   x11()
   x <- seq(-3,3,0.25)
   y <- x^2
   plot(x,y)
   plot (x,y, type="o") # 'p': puntos, "l": lines, 'b': puntos conectados mediante lineas, etc.
   # un ultimo ejemplo
   hist(extraversion, freq=F)
   curve(dnorm(x), add=T)
   detach(pers)
#+END_SRC
* Muestreo y probabilidad
** Muestreo
#+BEGIN_SRC R
   datos <- c(1,5,9,8,52,2,4)
   sample(datos,3)				# toma 3 elementos de 'datos'. Por defecto, muestrea SIN reposición

   dado <- 1:6						# para simular el lanzamiento de 5 dados hace falta muestreo CON reposición
   sample(dado,5,replace=T)
   # sample() tambien permite incluir un vector de pesos si los sucesos no son equiprobables
#+END_SRC
Otro ejemplo: extracción simultánea de dos cartas de una baraja española.
#+BEGIN_SRC R
   baraja <- paste(rep(c("As",2:7,"Sota","Caballo","Rey"),4),rep(c("Oros","Copas","Espadas","Bastos"),each=10));baraja
   sample(baraja,2)
#+END_SRC
Generacion de numeros pseudo-aleatorios.
#+BEGIN_SRC R
#  set.seed() # inicializa el generador de aleatorios con una semilla concreta (reproductibilidad)
   set.seed(-98)
#+END_SRC

** Distribuciones de probabilidad
Funciones de generacion de numeros pseudo-aleatorios conforme a una distrbucion dada
Estructura: rfunc(n, par1, par2,...)
#+BEGIN_SRC R
   datos.gauss <- rnorm (100, mean=5, sd=2)	# genera 100 numeros ~N(5,2)
   runif (4,-10,10)									# genera 4 numeros ~U(-10, 10)
#+END_SRC

Tambien existen rbinom, rpois, rt, rf, rchisq, rbeta, rgamma, etc en
ocasiones conviene mantener la semilla estable.

Funciones de densidad. Devuelven la ordenada de la funcion (de
densidad) de probabilidad para un vector de valores de la V.A.

Estructura: dfunc(n, par1, par2,..., log=FALSE)

#+BEGIN_SRC R
   x1 <- seq(-5,5,0.01)
   gauss <-dnorm(x1)
   plot (x1,gauss,"l", lwd=2, col="blue")
   student <- dt(x1, df=4)
   x11();
   plot (x1,student,"l", lwd=2,col="green")
   x2 <- seq(0,10,0.01)
   chi2 <-dchisq(x2,df=3)
   x11();
   plot (x2,chi2,"l",lwd=2,col="red")
#+END_SRC

Funciones de distribucion probabilidad
Estructura: pfunc(n, par1, par2,..., lower.tail = TRUE, log.p = FALSE)

#+BEGIN_SRC R
   pnorm(0.7)								# devuelve la prob de que una V.A.con distribución N(0,1) tome un valor menor o igual que 0.7
   pnorm(0.7, mean=10, sd=0.5)
   pchisq(3.84, df=3, lower.tail=F)	# devuelve la probabilidad de que una V.A.~ Chi2 con 3gl tome un valor mayor que 3.84
#+END_SRC

Funciones que devuelven cuantiles
Estructura: qfunc(n, par1, par2,..., lower.tail = TRUE, log.p = FALSE)

#+BEGIN_SRC R
  qnorm(0.025)						# devuelve el cuantil 2.5 (valor de la V.A. que deja por debajo el 2.5% de la distribución)
  qf(0.975, df1=4, df2=53)		# se puede usar para obtener los puntos de corte de la región de rechazo en un contraste de hipótesis
#+END_SRC

* Definicion de funciones

Estructura: nombre.funcion <- function(argumento1, argumento2){
		instruccion1; instruccion2; ...;
		return(variable.resultado)}
Las llaves no son necesarias si la funcion se define en una sola linea

Ejemplo: Definicion de una funcion que calcula la media

#+BEGIN_SRC R
	media <- function(datos){		# pueden darse valores por defecto a los argumentos
		numerador <-sum(datos)
		denominador <- length(datos)
		xm <- numerador/denominador				# podriamos llamar "media" a la variable de retorno
		return(xm)}										# devuelve al programa principal el VALOR de xm (pero la variable xm es local y sale)
#+END_SRC

Utilizacion de la funcion una vez definida (y cargada en memoria)

#+BEGIN_SRC R
   x <- rnorm(100)
   media(x)		# la llamada se hace mediante el nombre de la función
   mi.media <- media(datos=x);mi.media
#+END_SRC

Recomendaciones:
+ crear un directorio especifico para funciones propias
+ guardar cada funcion en un script independiente

Cargar una funcion en el espacio de trabajo, funcion source()

#+BEGIN_SRC R
  source("../funciones/descriptivos.r")	# carga la funcion 'descriptivos' que esta en el subdirectorio 'funciones'
  resultados <- descriptivos(x) 			# devuelve una LISTA de elementos que se almacenan en la variable 'resultados'
#+END_SRC

Para crear funciones minimamente complejas hace falta aquirir unos
minimos conocimientos de programación.
* Descriptivos
Cuando vamos a analizar unos datos lo primero que debemos mirar
normalmente son los descriptivos, veamos cómo:

#+BEGIN_SRC R
library(foreign)
# descriptivos de paises. Ejercicio 2.1
paises.csv <- read.csv('paises.csv', sep=';', na.strings=999)
media <- mean(paises.csv$Porcentaje)
mediana <- median(paises.csv$Porcentaje)
desviacionTipica <- sd(paises.csv$Porcentaje)
varianza <- var(paises.csv$Porcentaje)
cuantil <- quantile(paises.csv$Porcentaje)
todos <- summary(paises.csv$Porcentaje)
max <- max(paises.csv$Porcentaje)
min <- min(paises.csv$Porcentaje)
amplitud <- max - min
tr=c(3,4,5,3,4,5,4,3,2,3,12,11,3,4,89)
mean(tr,trim=5/100) # media recortada al 5%
IQR(tr)  # rango intercuartil
stem(tr) # diagrama de tallos y hojas (ver http://www.estadisticaparatodos.es/taller/graficas/tallos_hojas.html)
#+END_SRC

En nuestro ejemplo utilizaremos los datos de [[file:///home/davidam/public_html/software/R/paises.csv][paises.csv]]

* Licencia
Este documento está bajo una [[http://creativecommons.org/licenses/by/3.0/deed][Licencia Creative Commons Reconocimiento Unported 3.0]]

[[http://creativecommons.org/licenses/by/3.0/deed][file:http://i.creativecommons.org/l/by/3.0/80x15.png]]

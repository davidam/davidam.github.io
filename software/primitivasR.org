#+TITLE: Primitivas en GNU R
#+LANGUAGE: es
#+AUTHOR: David Arroyo Menéndez
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/org.css" />


* Básicas
** Configuración del Entorno

#+BEGIN_SRC R
getwd() 				      # Devuelve el 
                                              # directorio de trabajo 
setwd("/home/davidam/public_html/software/R") # Cambia el directorio 
                                              # de trabajo (debe 
                                              # existir previamente)
list.files()				      # Lista el contenido 
                                              # del directorio
                                              # de trabajo. Tambien ls()

source("/home/davidam/public_html/software/R/ejercicios-descriptivos.R")

q()                                           # Salir del entorno
#+END_SRC

** Ayuda on-line en R

#+BEGIN_SRC R
   help (aov)
   ?mean
   help.search('mean')
   ??'standard deviation'
   help.start() 			# abre una ventana del navegador
   example (mean)			# ejemplos del uso de mean
#+END_SRC

** Operaciones Aritméticas

#+BEGIN_SRC R
   5+7		# se evalua y el resultado se imprime 
                # por pantalla pero no se guarda
   5**7
   5-7
   5/7
   5^7          # elevado a
   51 %% 7	# modulo (resto de una division entera)
   51 %/% 7	# division entera
#+END_SRC

** Asignacion de valores a variables 

#+BEGIN_SRC R
   x <- 1	# asigna el valor 1 a la variable x
   x 		# lo escribe por pantalla
   y <- x^2
   x = 1	# una alternativa
   1 -> x 	# otra alternativa
#+END_SRC

** Funciones

#+BEGIN_SRC R
   q	# Muestra informacion de la funcion
   ?q
   # Algunas funciones elementales: log(), log10(), 
   # exp(), sqrt(), sin(), cos(), tan()
   # Mas funciones basicas: c(), max(), min(), 
   # pmax(), pmin(), range(), length(), sort() 
   # sum(), rowSums(), prod(), mean(), colMeans(), 
   # var(), cumsum(), etc.
   c(2,69,5,47,3647)
   sum(1,3,5,7)
   raiz64 <- sqrt(64)	# el resultado de una funcion 
                        # puede guardarse en una variable
   print(x)
   print(pi,digits=16); print(pi,digits=5)
#+END_SRC

** Listar y Eliminar Objetos del Espacio de Trabajo

#+BEGIN_SRC R
   ls()
   rm(x,raiz64)
   ls()
   rm(list=ls())
   ls()
#+END_SRC
* Tipos de Datos
** Booleanos
#+BEGIN_SRC R
verdad <- T
mentira <- F
edad <- c(27,30,29);
is.numeric(edad)
is.integer(edad)
is.double(edad)	# tambien existen is.complex(), 
                # is.logical(), is.character()...
typeof(edad)	# devuelve el tipo del objeto 
                # introducido como argumento
#+END_SRC
** Arrays
#+BEGIN_SRC R
calle <- c("c/ rue del percebe","28013"); 
#+END_SRC
** Conversiones de Tipo
#+BEGIN_SRC R
as.character(verdad)
as.numeric(verdad)		# doble precision por defecto
y <- c(0,1,27,14.9,NA,-3.2);y	# ojo, trunca en vez de redondear
as.logical(y)
as.character(y)
as.integer(y)
y<-c("hola", "adios","true","TRUE", "T", "F","129",NA ,"6");y
as.logical(y)
as.numeric(y)
#+END_SRC

* Vectores
** Básico
#+BEGIN_SRC R
x <- c(1,4,6,3,7); x
x[3]			# devuelve el valor guardado en 3a posicion
x[-4]			# devuelve todo excepto el valor 
                        # guardado en 4a posicion
x[1] <- 35		# guarda el valor 35 en la primer posicion
length(x)		# devuelve la longitud de x
x[11] <- 99; x
#+END_SRC
** Calculo vectorizado. Equivale a un bucle implicito
#+BEGIN_SRC R
x <- c(1,2,3,4,5)
y <- c(5,4,3,2,1)
x+y
y <- c(1,2,3);y
suma <- x+y; suma		# recicla el vector mas corto
suma2 <- x-1			# con escalares parece mas natural
x <- c(0.0001, 0.001, 0.01, 0.1, 1)
log10(x)			# muchas funciones tambien se 
                                # aplican vectorizadamente
#+END_SRC
** Generacion de secuencias regulares
#+BEGIN_SRC R
1:10
1:10-1				# el operador ':' tiene maxima prioridad
1:{10-1}
#funcion seq(from, to, by, length)
x <- seq (-3,3,0.5);x		# valores desde -3 hasta 3 a intervalos de 0.5	
seq (-3,3,length=10)		# 10 valores equiespaciados desde -3 hasta 3
seq (-3, by=0.5,length=10)	# 10 valores a intervalos de 0.5 desde -3
seq(along=x)			# Genera la secuencia 1, 2, 3,..., length(x)
#funcion rep(x, times, each)
x <- 1:4
rep(x,times=3)			# repite el contenido de x tres veces
rep(x,each=3)		        # repite cada elemento de x tres veces
rep(x,times=2,each=3)
rep(c(0,1),times=c(4,3))	# 'times' puede ser un vector. Aqui ya no cabe 'each'
x <- seq(19,6,-3);x
rep(x,1:length(x))		# 'times' puede estar implicito times={1:length(x)}
#+END_SRC
** Ordenacion de vectores
#+BEGIN_SRC R
x <- c(20,80,30,50,0)
order (x, decreasing=F)		# devuelve las posiciones del vector ordenadas segun su contenido
sort (x, decreasing=F)		# devuelve el contenido del vector ordenado
rank(x)				# devuelve el orden de cada posicion segun su contenido
min(x)
which.min(x)			# equivale a which(x == min(x))
x <- c(1,1,3:1,1:4,3); y <- c(0,9:1)
x.ord <- order(x,y)		# ordena los valores de x y, en caso de empate, utiliza los valores de y en las posiciones correspondientes. Ambos, x e y deben tener la misma longitud
x.ord;x;y
#+END_SRC
** Operadores comparativos: <, <=, >, >=, ==, !=
#+BEGIN_SRC R
x <- c(1:10); x
valor.verdad <- x>5; valor.verdad
x <- 1:10
x[x >= 5] <- 20; x	# condicional implicito
x[x == 1] <- 25; x
x <- 1:3; y <- 1:3
x == y			# equivalente a identical(x, y) o all.equal(x, y, tol=0)
y <- y+0.001; y
identical(x, y)
all.equal(x, y, tol=0.001)
#+END_SRC
** Operadores logicos: &,|, !, xor()
#+BEGIN_SRC R
a<-c(TRUE,TRUE,FALSE,FALSE) 
b<-c(F, T, F, T)
a&b
a|b
!(a&b)
(!a)|(!b)
#+END_SRC
** Identificacion y sustitucion de valores perdidos. Funciones is.na() y which()
#+BEGIN_SRC R
rm(list=ls())
x <- c(3,6,4,2,8,9)
print (x); length(x)
x[8:10] <- 3;x
is.na(x)
!is.na(x)
which(is.na(x))
x[is.na(x)]<-999;x	# codifica como 999 los valores perdidos
x==NA  			# la expresion logica x == NA sa un resultado muy distinto de
is.na(x)
#+END_SRC

Entonces si tenemos data$q_005 como un frame con algunos datos
perdidos y queremos solo los datos no perdidos podemos hacer

#+BEGIN_SRC 
data5 <- data$q_005[!is.na(data$q_005)]
#+END_SRC

** Indeterminaciones e infinito
#+BEGIN_SRC R
x <- c(0,7,8); x/x
1/x
-1/x
is.nan(x)
is.nan(x/x)
is.nan(1/x)
# Hay que tener cuidado con los NaN porque cualquier operacion con un NaN resulta en un NaN
#+END_SRC
** Manipulacion de vectores de caracteres
#+BEGIN_SRC R
# Concatena objetos en un vector de caracteres. Funcion paste(..., sep = " ", collapse = NULL)
juntar <- paste("Una ", "frase ", "cualquiera",  collapse ="");juntar
v1<-c("A","B")
v2<-2:3
codigos <- paste(v1,v2, sep = "");print(codigos)
codigos <- paste(v1,v2, sep = ".");print(codigos)
x <- paste(LETTERS[1:5]);x
x <- paste(LETTERS[1:5], collapse="");x

# Concatena e imprime. Funcion cat(... , file = "", sep = " ", fill = F, labels = NULL, append = F)
verano <- month.abb[7:9]; verano
cat(verano)			# el resultado no puede guardarse en ua variable
cat(verano,"\n")
cat(verano, sep=',')		# concatena separando con comas e imprime
cat(verano, sep=';', fill=3)
cat("Estaciones:","\t","Moncloa","\n", "\t", "\t","Aluche","\n")

#Todo junto: cat() y paste()
x<-2/3; cat(paste("resultado", signif(x,2), sep=" : " ),"\n")
#+END_SRC
** Indexacion de vectores mediante variables de caracteres. Funcion names()
#+BEGIN_SRC R
edad <- c(12,22,15,16,10)
names(edad)						# por defecto no se asignan nombres
names(edad) <- paste("suj#", sep = "",length(edad):1); edad
names(edad)
edad["suj#2"]					# devuelve la edad de Sujeto #2 (almacenado en la penultima posicion)
edad[length(edad)-1]
names(edad) <- NULL; edad	# elimina los nombre asignados
#+END_SRC
* Factores
Son vectores para datos categoricos. Permiten prescindir de la
codificacion numerica y referirse a los niveles mediante nombres
#+BEGIN_SRC R
   estudios <- c(1,3,1,1,3,4,3)
   factor(estudios)
   nivel.estudios <- factor(estudios, levels=1:4,labels=c("primarios", "secundarios", "superiores", "doctorado"), ordered=T)
   nivel.estudios
   factor(c(5,2,2,4,5,4,3,3,1), 2:5, exclude=4)	# los valores 1 y 4 se consideran valores perdidos
   # OJO. Internamente R siempre se asigna 1 al primer nivel del factor, 2 al segundo etc.
   levels(nivel.estudios)			# levels() extrae los posibles niveles de un factor
   as.numeric(nivel.estudios)		# recodifica el factor numericamente
   codigo.postal <- factor(c('28011', '28044', '28011','28013', '28013','28023'))
   equipo.futbol <- factor(c('VAL', 'VAL', 'FCB','VAL', 'FCB','ATM'))
   equipo.futbol						# ordena los factores alfabeticamente
   as.numeric(equipo.futbol)
   as.character(equipo.futbol)	# convierte en cadenas de caracters no en factor de nuevo
#+END_SRC

* Matrices
Suponen la generalizacion de vectores a 2D.
Todos los elementos de una matriz deben ser del mismo tipo.
Una convencion relativamente extendida es cmenzar con mayuscula el nombre de una matriz
** Función matrix()
#+BEGIN_SRC R
   X <- 1:12
   dim(X) <- c(4,3); X # los elementos se organizan por columnas
   matrix(1:12,nrow=3,ncol=4,byrow=T)
   matrix(1:12,nrow=4,byrow=T)
   Mi.matriz <- matrix(1:12,3,4,F); Mi.matriz
   tamano <- dim(Mi.matriz)		# otro uso de dim(); devuelve las dimensiones de la matriz
   rownames(Mi.matriz) <- LETTERS[1:tamano[1]]; Mi.matriz
   colnames(Mi.matriz) <- paste("Var",1:tamano[2], sep=""); Mi.matriz
   dimnames(Mi.matriz)
#+END_SRC
** Concatenación de matrices
#+BEGIN_SRC R
   X1 <- c(3,7,5)
   X2 <- c(8,3,1)
   Xx <- cbind(X1,X2);Xx
   Yy <- rbind(X2,X1);Yy
   Zz <- cbind(X1,Xx);Zz
#+END_SRC
** Indexacion de matrices
#+BEGIN_SRC R
   X <- matrix(c(1,4,12,15),2,2);X
   X[1,2]				# elemento guardado en la 1a fila, 2da columna
   X[1, ]				# todos los elementos de la primera fila
   X[ ,2]				# todos los elementos de la segunda columna
   X[3]   				# para pensar un poco...
   Mi.matriz['B',]	#tambien se pueden usar los nombres (se han asignado)
#+END_SRC
** Operaciones con matrices
#+BEGIN_SRC R
   X <- matrix(c(1,4,12,15),2,2); X
   Y <- matrix(1:4,2,2); Y
   X+Y
   X-Y
   X%*%Y						# producto matricial
   X*Y						# producto elemento por elemento
   t(X)						# traspuesta
   det(X)					# determinante
   X.inv <- solve (X)	# inversa de X (siempre que X sea cuadrada no singular, claro)
   X.inv
   X%*%X.inv				# Comprueba el resultado. Ojo a los errores de redondeo
   # En general, solve(a,b) es una funcion que resuelve a %*% x = b para x, donde b puede ser un vector o una matriz. Si no se explicta se asume que es la matriz identidad y la funcion devuelve la inversa de a
   A <- matrix(c(1,4,12,15),2,2); A
   B <- matrix(c(5,2),2,1);B
   X <- solve(A,B); X
   A%*%X			# comprueba que el resultado es efectivamente B
#+END_SRC
** Algunas funciones que operan sobre filas o columnas completas
#+BEGIN_SRC R
   X <- matrix(c(1,4,12,15),2,2); X
   rowSums(X)
   colSums(X)
   rowMeans(X)
   colMeans(X)
#+END_SRC
** Apply
#+BEGIN_SRC R
   apply(X,1,sum)		# suma por filas; equivale a rowSums(X)
   apply(X,2,mean)	# media por columnas; equivale a colMeans(X)
   apply(X,1,sd)
#+END_SRC
** Matrices multidimensionales (arrays)
#+BEGIN_SRC R
   A <- array(1:24, c(3, 4, 2)); A
   dimnames(A) <- list(c("fila1", "fila2", "fila3"), c("col1", "col2", "col3", "col4"), c("capa 1", "capa 2"));A
#+END_SRC
* Listas
Son una especie de contenedores generales donde pueden mezclarse todo
tipo de componentes (objetos de cualquier tipo y cualquier longitud)

Son unos objetos poco estructurados y, por tanto, muy flexibles.

Muchas funciones nativas de R devuelven el resultado en forma de
lista
#+BEGIN_SRC R
   rm(list=ls())
   mis.num <- seq(1.0, 2.0, 0.1); mis.num2 <- 2:4
   Mi.matriz <- matrix(1:12,3,4); Mi.matriz
   mis.caracteres <- paste(LETTERS[1:5]);mis.caracteres
   mis.logicos <- mis.num > 1.65; mis.logicos
   lista1 <- list(mis.num, mis.num2, Mi.matriz, mis.caracteres,mis.logicos)
   lista1
#+END_SRC
** Indexacion, nombres y atributos
#+BEGIN_SRC R
   length(lista1)		# devuelve el numero de componentes de la lista
   str(lista1) 		# devuelve informacion sobre la estructura de la lista
   a <- lista1[[1]]	# devuelve el 1er objeto de la lista en forma de vector/matriz (y nombre  excluido)
   a; typeof(a)
   b <- lista1[1]		# devuelve una sublista compuesta por los elementos de la 1a entrada de la lista (nombre incluido)
   b; typeof(b)

   nomb <- c("reales","enteros", "matriz", "caracteres", "logicos")
   names(lista1) <- nomb; 	# asigna nombres a los componenes de la lista 
   names(lista1)				# devuelve los nombres de los componentes (si los hay)
   lista1[["reales"]]
   lista1$logicos 			# equivalente a lista1[["logicos"]] y a lista[[5]]

   # Otro modo de definir una lista que incluye nombres para los componentes
   lista2 <- list(A=mis.num, B=mis.num2); lista2
   names(lista2)
#+END_SRC

** Attach
Las funciones attach() y detach () "cargan" listas y simplifican las referencias. 
#+BEGIN_SRC R
   attach(lista1, warn.conflicts = T)
#+END_SRC

* Hojas de datos (data frames)
Son un tipo especial de lista:
+ con estructura tabular
+ donde las columnas pueden ser de distinto tipo
+ suelen utilizarse como bases de datos donde cada fila representa una unidad de observacion y cada columna una variable 

#+BEGIN_SRC R
   var1 <- seq(150,700,50); var2 <- 6:17; var3 <- c(10, 35, 17); var4 <- 2:8
   data.frame(var1, var2) 
   data.frame(var1, var3) # recicla var3
   data.frame(var1, var4) # mensaje de error porque la longitud var1 no es multiplo de la de var4
   var5 <- factor(rep(c(2,1,1,1), times=3), levels=1:2, labels=c("UsaTwitter", "NoUsaTwitter"));var5
   mis.datos <- data.frame(var5, var1, var2, var3);mis.datos # por defecto los nombres de las columnas corresponden a los nombres de los objetos
   # para nombrar las filas (no siempre necesario)
   row.names(mis.datos) <- paste("suj",1:max(length(var1),length(var2),length(var3)), sep='');mis.datos	# Equivale a rownames(mis.datos)
#+END_SRC

** Algunos atributos
#+BEGIN_SRC R
   rownames(mis.datos); colnames(mis.datos)
   dim(mis.datos)				# dimensiones
   str(mis.datos)				# estructura
   attributes(mis.datos)	# clase y nombres de fila y columna
#+END_SRC

** Particiones de una hoja de datos segun un factor, funcion split()
Uso: split (x, factor). unsplit(x, factor)
#+BEGIN_SRC R
   trozos <- split (mis.datos, mis.datos$var5); trozos		# devuelve una lista "trozos" con los valores de var1 segregados segun var5
   typeof(trozos)
   junto.otravez <- unsplit(trozos, mis.datos$var5); junto.otravez

   # el 2do argumento funciona como factor, no es necesario que este definido como tal.
   # Ademas se pueden seleccionar solo algunas variables (ej, var2 y var3)
   trozos <- split (c(mis.datos$var1,mis.datos$var2), mis.datos$var3); trozos

   # lo mismo podria conseguirse con una sucesion de instrucciones como esta:
   twitter.si <- mis.datos[mis.datos$var5=="UsaTwitter",];twitter.si
#+END_SRC

** Filtrado segun condiciones logicas. Función subset()
Uso: subset(x, subset, select)
#+BEGIN_SRC R
   subset(mis.datos, var3 >= 15)
   subset(mis.datos, var3 >= 15, select=c(var1,var2))
   subset(mis.datos, var3 >= 15, select=-var3)
#+END_SRC

#+BEGIN_SRC R
   subset(data$q_005, (data$q_005 > 1900) & (data$q_005 < 2013))
#+END_SRC

** Transformaciones de datos, funcion transform()
Uso: transform()
#+BEGIN_SRC R
   mis.datos2 <- transform (mis.datos, log.var1= log(var1)); mis.datos2
#+END_SRC

** Edición manual de bases de datos
R dispone de una utilidad de aspecto sejemante a una hoja de calculo para:
+ introducir datos manualmente
+ modificar unos pocos elementos de bases de datos existentes

#+BEGIN_SRC R
  edit(data.frame())			# abre el editor con una 'hoja de datos' vacia
						# los huecos se rellenaran solos con NA
						# doble click en "var?" para cambiar el nombre de la variable
 						# ¿que ha pasado?, ¿donde estan los datos?
   respuestas <- edit(data.frame())	# Es esencial asignarle un nombre a la hoja de datos
   respuestas
   respuestas2 <- edit(respuestas)	# guarda los cambios en una nueva hoja de datos (y conserva la antigua)
   respuestas;respuestas2
   fix(respuestas)						# sobreescribe los cambios. Es equivalente a respuestas <- edit(respuestas)	
#+END_SRC

* Cargar datos nativos de R
La instalacion basica de R incluye el paquete 'datasets'.
#+BEGIN_SRC R
   data()									# lista todas las bases de datos disponibles en datasets'
   help(women)								# informacion sobre ese conjunto de datos concreto
   data(women, package="datasets")	# carga esos datos
   # Si el paquete de procedencia esta cargado basta simplemente:
   women	
   data(women)								# Equivalente data('women')
#+END_SRC

Muchos paquetes adicionales tambien vienen con sus datos de ejemplo

* Paquetes R
Cargar un paquete. Requiere instalarlo previamente bien:
+ descargandolo en www.r-project.org y siguiendo las instrucciones
+ utilizando el menu windows de RGui y eligiendo un repositorio
+ con la función install.packages("package")
#+BEGIN_SRC R
   library (foreign)			# o mediante el menu windows de RGui
   library(help=foreign) 	# informacion sobre el paquete 'foreign'
#+END_SRC

** Ruta de busqueda (search path).
Puede haber muchos objetos con el mismo nombre en distintos paquetes.
La ruta de busqueda explicita el orden en que se van a recorrer los
paquetes para buscar objetos partes deOrden en el que R
#+BEGIN_SRC R
   search()		# muestra la ruta de busqueda
   # Cuidado con los nombres de las variables del espacio de trabajo: Tienen prioridad
   rm(list=ls())
   women
   attach(women)
   mean(weight)
   weight <- 0; mean(weight)
   mean(women$weight)
#+END_SRC

** ACERCA de attach()
attach() inserta el paquete en la ruta de busqueda de R de modo que todos los objetos del paquete estan accesibles mediante sus nombres
Uso: attach(what, pos = 2, name = deparse(substitute(what)), warn.conflicts = TRUE)
Precauciones:
+ Cuidado con el enmascaramiento (nombres duplicados)
+ attach no proporciona actualizacion dinamica de los objetos

*** Retirar paquetes
#+BEGIN_SRC R
   detach (package:ISwR)
   detach()		# elimina el paquete que haya en 2a posicion
   plot(c(1,2,5,6), c(2,5,6,7)) # representa un diagrama de dispersion (vease la seccion 'Graficos')
   detach()		# elimina el nuevo 2do paquete
   plot(c(1,2,5,6), c(2,5,6,7))
#+END_SRC

* Escritura de datos en un archivo
** Guardar en un archivo de texto plano una hoja de datos. Funcion write.table()
#+BEGIN_SRC R
   rm(list=ls())
   data(women)
   write.table(women, "../datos/mujeres.dat", append=T)	# Si la carpeta datos no existe previamente dara un mensaje de error
   ?write.table
   write.table(women, "../datos/mujeres.dat", append=T, row.names=F, col.names= F, sep='', dec=',')
   write.table(women, "../datos/mujeres.dat", append=F,quote=F)
#+END_SRC

** Guadar en texto plano cualquier objeto. Funcion write(). Es mas general, pero no funciona bien con data frames
#+BEGIN_SRC R
   x<-seq(1,3,0.1) 
   write(x,"../datos/numeros.dat", ncolumns=1,append=T)
   write(x,"../datos/numeros.dat", ncolumns=length(x),append=F)
#+END_SRC

* Lectura de datos desde un archivo
** Informacion completa en el manual "R Data Import/Export" accesible desde la ayuda

Es posible cargar datos desde un fichero de texto y hacer algún cálculo.

#+BEGIN_SRC R
   ?read.table
   rm(list=ls())
   mis.datos <- read.table("../datos/mujeres.dat", header=T, check.names=T, sep=" ",na.strings=999, comment.char = "#")
   edit(mis.datos)
   median(mis.datos$weight)
   colMeans(mis.datos)
   attach(mis.datos)
   sum(weight >=125)/length(weight)		# calcula la proporcion de individuos que pesan al menos 125 lb
#+END_SRC

También es posible cargar datos desde un fichero de texto y manipular datos.

#+BEGIN_SRC R
rm(list=ls(all=TRUE))
b=read.table("Oster.txt", header=T)
dim(b)
summary(b)
names(b)# obtengo los nombres de las cabeceras de columna
head(b)# Quiero ver los 6 primeros valores
tail(b) # Los seis últimos
attach(b)# anclamos la base de datos para trabajar con ella 
View(b)# Veo mis datos
edit(b)
#+END_SRC

** Existen variantes de read.table() para formatos algunos formatos habituales: read.csv, read.csv2, read.delim ...
Tambien hay multiples paquetes como 'foreign' para leer archivos creados por programas como SPSS, SAS, Minitab, etc., 
aunque resulta mas comodo usar esos programas para guardar los datos en texto plano y usar read.table para importar a R

#+BEGIN_SRC R
   library(foreign)	# En primer lugar hay que cargar el paquete
   mi.encuesta.spss <- read.spss("../datos/SurveyStatisticsI.sav", to.data.frame=T)
   edit(mi.encuesta.spss)
#+END_SRC

Mas informacion sobre el uso de foreign en el pdf descargable junto
con el paquete.

Paquete para importar y exportar datos de excel: ‘xlsReadWrite’ (no
incluido en el sistema base; hay que importarlo)

** Funcion scan(). 
Mas flexible pero mas complicada de utilizar. Permite especificar el modo de las variables
#+BEGIN_SRC R
   ?scan
   mis.datos <- scan("../datos/mujeres.dat", what = list(character(), numeric(),numeric()), skip=1);mis.datos
   mis.datos2 <- scan("../datos/mujeres.dat", what = list(0,0,0), skip=3)
#+END_SRC

* Gráficos
R tiene un sistema de graficos muy completo que permite producir graficos con calidad de publicacion
Hay múltiples funciones, parametros y paquetes graficos. Se van aprendiendo a medida que se van utilizando
Para una buena introduccion: R for Beginners de E. Paradis (citado en la documentacion)
** Gestion de ventanas graficas
#+BEGIN_SRC R
   x11()									# abre una nueva ventana grafica (Unix y Wndows)
   windows(width=15, height=15, title='Figura 1')	# abre una nueva ventana grafica (Windows)
   quartz()								# abre una nueva ventana grafica (Mac OS)
   pdf("prueba.pdf")					# abre un pdf de nombre "prueba.pdf" y redirige el output gráfico al archivo pdf
   postscript("prueba.eps")		# abre un archivo de postscript encapsulado de nombre "prueba.eps" y redirige el output gráfico

   dev.list()	# lista todos los dispositivos grafico abiertos. Los nums son los identificadores
   dev.cur() 	# devuelve el identificador del dispositivo grafico activo
   dev.set(2)	# establece como dispositivo gráfico activo el dispositivo num 2
   dev.off() 	# cierra el dispositivo grafico activo; dev.off(3) cierra el dispositivo grafico num 3
#+END_SRC

** Funcion plot(). Es la función gráfica basica. 
Segun los argumentos puede generar un diagrama de dispersion, de barras, caja y bigotes etc.
#+BEGIN_SRC R
   x <- 1:15; y <- 30:16
   # con datos cuantitativos produce diagramas de dispersion
   plot (x,y, pch=2)
   plot(women)		# puede usarse una hoja de datos o matriz. OJO solo toma las 2 primeras columnas
   plot(y)			# representa los valores de 'y' en funcion de su posicion en el vector

   # plot (factor) produce un diagrama de barras
   f <- factor(rep(c(1,2,2,1,1,3), each=2), levels=1:3, labels=c("No fumador", "Fumador", "NS/NC"))
   plot(f)
   # tambien existe la funcion barplot para crear diagramas de barras

   # plot (var.cuant, factor) produce diagramas de caja organizados según los niveles del factor
   entorno <- factor(rep(c(1,2,2), each=5), levels=1:2, labels=c("Urbano", "Rural"))
   plot(entorno,y)
#+END_SRC
** Plot a Png
Se usa la función png para almacenar la salida en un fichero de imagen.
#+BEGIN_SRC R
   x <- 1:15; y <- 30:16
   # con datos cuantitativos produce diagramas de dispersion
   png(filename="/tmp/figure.png", height=295, width=300, bg="white")
   plot (x,y, pch=2)
   dev.off()
#+END_SRC
** Funcicion coplot(). Matriz de graficos de dispersion separados segun factores
#+BEGIN_SRC R
   datos2 <- data.frame(entorno,women)
   coplot(women$weight ~ women$height | entorno) # representa peso en funcion de altura separando segun entorno
   socioeconomico<- factor(c(3,3,2,2,2,2,1,1,1,1,1,1,1,2,2), levels=1:3, labels=c("bajo","medio","alto"))
   plot(socioeconomico)
   coplot(women$weight ~ women$height | entorno+socioeconomico)
#+END_SRC

** Funcion pairs(). Ejemplo con datos simulados de los "Big Five" de personalidad
#+BEGIN_SRC R
   pers <- matrix(rnorm(1000), ncol = 5)	# genera 1000 datos con distribucion normal. Vease seccion 'Muestreo y probabilidad'
   colnames(pers) <- c("extraversion", "estabilidad", "apertura", "responsabilidad", "amabilidad")
   pairs(pers)
   # Nótese la diferencia con el resultado de plot()
   x11(); plot(pers)			# usa solo las 2 primeras variables
#+END_SRC

** Funcion hist(). Histogramas
#+BEGIN_SRC R
   pers <- as.data.frame(matrix(rnorm(1000), ncol = 5))
   colnames(pers) <- c("extraversion", "estabilidad", "apertura", "responsabilidad", "amabilidad")
   cor(pers, method='pearson')	# matriz de correlaciones. Otros metodos: 'spearman' y 'kendall'
   round(cor(pers),3)	# la misma matriz de antes, pero con solo 3 decmales
   attach(pers)
   hist(extraversion)
   x11(); hist(extraversion, labels=T, col= "gray", xlim=c(-4,4), ylab="Frecuencia absoluta", sub= "Figura 1. Ejemplo de histograma", main= "Extraversión")
   hist(amabilidad, col= "red", border="white", add=T, xlim=c(-4,4), sub= "Figura 2. Otro ejemplo de histograma", main= c("Extraversión  Amabilidad superpuestos"))
   x11(); hist(extraversion,freq=F, labels=T, col= "light blue",xlim=c(-4,4),ylab="Frecuencia relativa", las=1,sub= "Figura 1b. Ejemplo de histograma", main= "Extraversión")
   hist(amabilidad, col= "gray", border="white", xlim=c(-4,4), sub="", main= "Figura 3. Otro ejemplo de histograma cambiando el color")	

   pdf("ejemplos_histograma.pdf")
   hist(extraversion, nclas=3, col= "light blue", sub= "Figura 3. Ejemplo de histograma", main= "Extraversión")
   hist(extraversion, breaks=seq(-4,4,0.5),col= "pink",main= "Figura 3. Ejemplo de histograma")
   dev.off()
#+END_SRC

** Funcion boxplot()
#+BEGIN_SRC R
   boxplot(extraversion, main= "Diagrama de caja de extraversión")
   text(locator(5),"más outliers", adj=0) 
   boxplot(pers)
#+END_SRC

** Funciones qqnorm() y qline
#+BEGIN_SRC R
   qqnorm(extraversion, col="red")
   qqline(extraversion)
#+END_SRC
Tambien existe qqplot(), que permite utilizar otras distribuiones distintas de la normal

** Catalogo de nombres de color
#+BEGIN_SRC R
   colors()
#+END_SRC

** Parametros gráficos. Funcion par()
Produce cambios permanentes en el dispositivo gráfico activo
Permite contral cada elemento del grafico final
#+BEGIN_SRC R
   ?par
   par.actual <- par()		# guarda los valores actuales (para poder reestablecerlos posteriormente)
   par(font.main=4, las=1, xaxs= "r", col.lab="blue", col="skyblue3",lwd=3)
   hist(extraversion,xlim=c(-4,4))
   plot(extraversion, amabilidad)
#   par(par.actual)			# reestablece los valores guardados
   par(mfrow=c(2,1))		# distribuye el espacio grafico e dos filas
#+END_SRC

** Representacion de funciones
#+BEGIN_SRC R
   curve(x^2)
   curve(x^2, from=-3, to=3) # los cambios introducidos a traves de par no tienen efecto en la nueva ventana
   # tambien podria haberse hecho con plot
   x11()
   x <- seq(-3,3,0.25)
   y <- x^2
   plot(x,y)
   plot (x,y, type="o") # 'p': puntos, "l": lines, 'b': puntos conectados mediante lineas, etc.
   # un ultimo ejemplo
   hist(extraversion, freq=F)
   curve(dnorm(x), add=T)
   detach(pers)  
#+END_SRC
** Curvas de nivel y 3d
#+BEGIN_SRC R
#podemos crear secuencias
x=seq(1,10)

x=seq(-pi,pi,length=50)

#pintamos curvas de nivel
y=x
f=outer(x,y,function (x,y)cos(y)/(1+x^2))
contour (x,y,f)
fa=(f-t(f))/2 #transpuesta
contour(x,y,fa,nlevels=15)

#pintameos imagenes y 3d
image(x,y,fa)
persp(x,y,fa)
persp(x,y,fa,theta=30)
persp(x,y,fa,theta=30,phi=20) 
persp(x,y,fa,theta=30,phi=70) 
persp(x,y,fa,theta=30,phi=40)
#+END_SRC

* Muestreo y probabilidad
** Muestreo
#+BEGIN_SRC R
   datos <- c(1,5,9,8,52,2,4)
   sample(datos,3)				# toma 3 elementos de 'datos'. Por defecto, muestrea SIN reposición

   dado <- 1:6						# para simular el lanzamiento de 5 dados hace falta muestreo CON reposición
   sample(dado,5,replace=T)
   # sample() tambien permite incluir un vector de pesos si los sucesos no son equiprobables
#+END_SRC
Otro ejemplo: extracción simultánea de dos cartas de una baraja española.
#+BEGIN_SRC R
   baraja <- paste(rep(c("As",2:7,"Sota","Caballo","Rey"),4),rep(c("Oros","Copas","Espadas","Bastos"),each=10));baraja
   sample(baraja,2)
#+END_SRC
Generacion de numeros pseudo-aleatorios.
#+BEGIN_SRC R
#  set.seed() # inicializa el generador de aleatorios con una semilla concreta (reproductibilidad)
   set.seed(-98)
#+END_SRC

** Distribuciones de probabilidad
Funciones de generacion de numeros pseudo-aleatorios conforme a una distrbucion dada
Estructura: rfunc(n, par1, par2,...)
#+BEGIN_SRC R
   datos.gauss <- rnorm (100, mean=5, sd=2)	# genera 100 numeros ~N(5,2)
   runif (4,-10,10)									# genera 4 numeros ~U(-10, 10)
#+END_SRC

Tambien existen rbinom, rpois, rt, rf, rchisq, rbeta, rgamma, etc en
ocasiones conviene mantener la semilla estable.

Funciones de densidad. Devuelven la ordenada de la funcion (de
densidad) de probabilidad para un vector de valores de la V.A.

Estructura: dfunc(n, par1, par2,..., log=FALSE)

#+BEGIN_SRC R
   x1 <- seq(-5,5,0.01)
   gauss <-dnorm(x1)
   plot (x1,gauss,"l", lwd=2, col="blue")
   student <- dt(x1, df=4)
   x11();
   plot (x1,student,"l", lwd=2,col="green")
   x2 <- seq(0,10,0.01)
   chi2 <-dchisq(x2,df=3)
   x11();
   plot (x2,chi2,"l",lwd=2,col="red")
#+END_SRC

Funciones de distribucion probabilidad
Estructura: pfunc(n, par1, par2,..., lower.tail = TRUE, log.p = FALSE)

#+BEGIN_SRC R
   pnorm(0.7)								# devuelve la prob de que una V.A.con distribución N(0,1) tome un valor menor o igual que 0.7
   pnorm(0.7, mean=10, sd=0.5)
   pchisq(3.84, df=3, lower.tail=F)	# devuelve la probabilidad de que una V.A.~ Chi2 con 3gl tome un valor mayor que 3.84
#+END_SRC

Funciones que devuelven cuantiles
Estructura: qfunc(n, par1, par2,..., lower.tail = TRUE, log.p = FALSE)

#+BEGIN_SRC R
  qnorm(0.025)						# devuelve el cuantil 2.5 (valor de la V.A. que deja por debajo el 2.5% de la distribución)
  qf(0.975, df1=4, df2=53)		# se puede usar para obtener los puntos de corte de la región de rechazo en un contraste de hipótesis
#+END_SRC

* Definicion de funciones

Estructura: nombre.funcion <- function(argumento1, argumento2){
		instruccion1; instruccion2; ...;
		return(variable.resultado)}
Las llaves no son necesarias si la funcion se define en una sola linea

Ejemplo: Definicion de una funcion que calcula la media

#+BEGIN_SRC R
	media <- function(datos){		# pueden darse valores por defecto a los argumentos
		numerador <-sum(datos)
		denominador <- length(datos)
		xm <- numerador/denominador				# podriamos llamar "media" a la variable de retorno
		return(xm)}										# devuelve al programa principal el VALOR de xm (pero la variable xm es local y sale)
#+END_SRC

Utilizacion de la funcion una vez definida (y cargada en memoria)

#+BEGIN_SRC R
   x <- rnorm(100)
   media(x)		# la llamada se hace mediante el nombre de la función
   mi.media <- media(datos=x);mi.media
#+END_SRC

Recomendaciones: 
+ crear un directorio especifico para funciones propias
+ guardar cada funcion en un script independiente

Cargar una funcion en el espacio de trabajo, funcion source()

#+BEGIN_SRC R
  source("../funciones/descriptivos.r")	# carga la funcion 'descriptivos' que esta en el subdirectorio 'funciones'
  resultados <- descriptivos(x) 			# devuelve una LISTA de elementos que se almacenan en la variable 'resultados'
#+END_SRC

Para crear funciones minimamente complejas hace falta aquirir unos
minimos conocimientos de programación.
* Descriptivos
Cuando vamos a analizar unos datos lo primero que debemos mirar
normalmente son los descriptivos, veamos cómo:

#+BEGIN_SRC R
library(foreign)
# descriptivos de paises. Ejercicio 2.1
paises.csv <- read.csv('paises.csv', sep=';', na.strings=999)
media <- mean(paises.csv$Porcentaje)
mediana <- median(paises.csv$Porcentaje)
desviacionTipica <- sd(paises.csv$Porcentaje)
varianza <- var(paises.csv$Porcentaje)
cuantil <- quantile(paises.csv$Porcentaje)
todos <- summary(paises.csv$Porcentaje)
#+END_SRC

En nuestro ejemplo utilizaremos los datos de [[file:///home/davidam/public_html/software/R/paises.csv][paises.csv]]


* Test estadísticos
** Test Binomial

Supongamos que tenemos un juego de mesa que depende del lanzamiento de
un dado (ver dado) y asigna una especial importancia al lanzamiento de
un 6. En un juego en particular, el dado es lanzado 366 veces, y el 6
sale 51 veces. Si el dado es justo, esperamos que el 6 salga 366/6 =
61 veces. ¿Es la proporción del 6 significativamente más alta de lo
que se esperaría por casualidad, sobre la hipótesis nula de un dado
justo?

#+BEGIN_SRC R
binom.test(51, 336, (1/6))
#+END_SRC

** Distribución Binomial

Si hay doce coches cruzando un puente por minuto de media, encuentra
la probabilidad de tener dieciseis o más coches cruzando el puente en
un minuto particular.

#+BEGIN_SRC R
> ppois(16, lambda=12)   # lower tail 
[1] 0.89871

> ppois(16, lambda=12, lower=FALSE)   # upper tail 
[1] 0.10129
#+END_SRC

La probabilidad es del 10.1%

** Distribución F

El 95 percentil de la distribución F con (5, 2) grados de libertad es
19.296

#+BEGIN_SRC R
> qf(.95, df1=5, df2=2) 
[1] 19.296
#+END_SRC


** Test de Chi

Establezcamos la hipótesis del hábito de fumar de los estudiantes es
independiente de su nivel de ejercicio en un nivel de significancia de
0.05.

#+BEGIN_SRC R
> library(MASS)       # load the MASS package 
> tbl = table(survey$Smoke, survey$Exer) 
> tbl                 # the contingency table 
 
        Freq None Some 
  Heavy    7    1    3 
  Never   87   18   84 
  Occas   12    3    4 
  Regul    9    1    7

> chisq.test(tbl) 
 
        Pearson’s Chi-squared test 
 
data:  table(survey$Smoke, survey$Exer) 
X-squared = 5.4885, df = 6, p-value = 0.4828 
 
Warning message: 
In chisq.test(table(survey$Smoke, survey$Exer)) : 
  Chi-squared approximation may be incorrect
#+END_SRC

Como el p-valor es 0.4828 es mayor que el nivel de significado 0.05,
no rechazamos la hipótesis nula que el hábito de fumar es
independiente del nivel de ejercicio de los estudiantes.

** Test Wilcox

Sin asumir que los datos tienen distribución normal, chequea en el
nivel de significación 0.05 si los rendimientos entre 1931 y 1932 en
los datos tienen distribuciones de datos idénticas.

#+BEGIN_SRC R
> library(MASS)         # load the MASS package 
> head(immer) 
  Loc Var    Y1    Y2 
1  UF   M  81.0  80.7 
2  UF   S 105.4  82.3 

> wilcox.test(immer$Y1, immer$Y2, paired=TRUE) 
 
        Wilcoxon signed rank test with continuity correction 
 
data:  immer$Y1 and immer$Y2 
V = 368.5, p-value = 0.005318 
alternative hypothesis: true location shift is not equal to 0 
 
Warning message: 
In wilcox.test.default(immer$Y1, immer$Y2, paired = TRUE) : 
  cannot compute exact p-value with ties
#+END_SRC

Las distribuciones son NO idénticas.

** Ecuación de la Regresión Logística

Para un coche de 120 km/h y un peso de 2800, la probabilidad de estar
ajustado es del 64%.

#+BEGIN_SRC R
> am.glm = glm(formula=am ~ hp + wt, data=mtcars, family=binomial)
> newdata = data.frame(hp=120, wt=2.8)
> predict(am.glm, newdata, type="response") 
#+END_SRC

** Test de significado para la regresión logística

En el nivel de significado 0.05, decidimos si cualquiera de las
variables independientes en el modelo de regresión logística de la
transmisión del vehículo en los datos asigna mtcars es
estadísticamente insignificante.

#+BEGIN_SRC R
> am.glm = glm(formula=am ~ hp + wt, 
+              data=mtcars, 
+              family=binomial)

> summary(am.glm) 
 
Call: 
glm(formula = am ~ hp + wt, family = binomial, data = mtcars) 
 
Deviance Residuals: 
    Min       1Q   Median       3Q      Max 
-2.2537  -0.1568  -0.0168   0.1543   1.3449 
 
Coefficients: 
            Estimate Std. Error z value Pr(>|z|) 
(Intercept)  18.8663     7.4436    2.53   0.0113 * 
hp            0.0363     0.0177    2.04   0.0409 * 
wt           -8.0835     3.0687   -2.63   0.0084 ** 
--- 
Signif. codes:  0 *** 0.001 ** 0.01 * 0.05 . 0.1   1 
 
(Dispersion parameter for binomial family taken to be 1) 
 
    Null deviance: 43.230  on 31  degrees of freedom 
Residual deviance: 10.059  on 29  degrees of freedom 
AIC: 16.06 
 
Number of Fisher Scoring iterations: 8
#+END_SRC
** Mann-Whitney test: comparar si hay diferencias entre medianas muestras independientes

#+BEGIN_SRC R
boxplot(Peso ~ Manejo)
wilcox.test(Peso~Manejo)
boxplot(Ostertagia ~ Manejo)
plotmeans(Ostertagia~Manejo,col="coral", connect=T, ylab="Carga parasitaria (Ostertagia)", xlab="Manejo", data=b)# plot means and CI95% Grafica mitjana
#+END_SRC


* Regresión Lineal 

En estadística la regresión lineal o ajuste lineal es un modelo
matemático usado para aproximar la relación de dependencia entre una
variable dependiente Y, las variables independientes Xi y un término
aleatorio.

En regresión lineal simple tenemos hay una variable independiente y en
regresión lineal múltiple hay muchas variables independientes.

** Ecuación de Regresión Lineal Simple

Aplica regresión lineal para el conjunto de datos faithful, y estima
la duración de la siguiente erupción si el tiempo de espera han sido
80 minutos.

#+BEGIN_SRC R
> eruption.lm = lm(eruptions ~ waiting, data=faithful)
> coeffs = coefficients(eruption.lm); coeffs 
(Intercept)     waiting 
  -1.874016    0.075628
> waiting = 80           # the waiting time 
> duration = coeffs[1] + coeffs[2]*waiting 
> duration 
(Intercept) 
     4.1762
#+END_SRC

Si el tiempo de espera han sido 80 minutos, esperamos que la siguiente
erupción son 4.1762 minutos.

** Coeficiente de Determinación 

Encuentra el coeficiente de determinación para el modelo de regresión
lineal simple del conjunto de datos faithful.

#+BEGIN_SRC R
> eruption.lm = lm(eruptions ~ waiting, data=faithful)
> summary(eruption.lm)$r.squared 
[1] 0.81146
#+END_SRC

** Test de significado para la regresión lineal

Decide si hay una regresión significativa entre las variables en el
modelo de regresión lineal del conjunto de datos faithful en el nivel
de significación 0.05.

#+BEGIN_SRC R
> eruption.lm = lm(eruptions ~ waiting, data=faithful)
> summary(eruption.lm) 
 
Call: 
lm(formula = eruptions ~ waiting, data = faithful) 
 
Residuals: 
    Min      1Q  Median      3Q     Max 
-1.2992 -0.3769  0.0351  0.3491  1.1933 
 
Coefficients: 
            Estimate Std. Error t value Pr(>|t|) 
(Intercept) -1.87402    0.16014   -11.7   <2e-16 *** 
waiting      0.07563    0.00222    34.1   <2e-16 *** 
--- 
Signif. codes:  0 ’***’ 0.001 ’**’ 0.01 ’*’ 0.05 ’.’ 0.1 ’ ’ 1 
 
Residual standard error: 0.497 on 270 degrees of freedom 
Multiple R-squared: 0.811,      Adjusted R-squared: 0.811 
F-statistic: 1.16e+03 on 1 and 270 DF,  p-value: <2e-16
#+END_SRC

Como el p-valor es mucho menor que 0.05, se rechaza la hipótesis nula.

* Licencia
Este documento está bajo una [[http://creativecommons.org/licenses/by/3.0/deed][Licencia Creative Commons Reconocimiento Unported 3.0]]

[[http://creativecommons.org/licenses/by/3.0/deed][file:http://i.creativecommons.org/l/by/3.0/80x15.png]]
